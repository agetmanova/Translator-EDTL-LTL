# -*- coding: utf-8 -*-
"""Translator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QCiyYtfYkXxKcvjka9Ow1DfWqC5GtE0K
"""

def dis(a, b):
  if (a == True) or (b == True): return True;
  elif (a == False): return b;
  elif (b == False): return a;
  #a ∨ a = a
  elif ((type(a) != type(True)) and (type(b) != type(True)) and (a == b)):
    rules[0][1]+=1;
    return a;
  #a ∨ (b ∧ (a ∨ c)) = a ∨ (b ∧ c)
  elif (b.find('∧ ('+a+' ∨ ') >= 0):
    b2 = b.replace('('+a+' ∨ ', '');
    b2 = b2.replace( ')', '', 1);
    rules[1][1]+=1;
    return '(' +a+ ' ∨ ' +b2+ ')';
  #a ∨ F(a ∨ b) = F(a ∨ b)
  elif (b.find('F('+a+' ∨ ') >= 0): 
    rules[2][1]+=1;
    return b;
  #a ∨ (b U a) = (b U a)
  elif ((b[0:1] == '(') and (b.find (' U '+a+')') >= 0)): 
    rules[3][1]+=1;
    return b;
  #a ∨ F(b U a) = F(b U a)  
  elif ((b[0:2] == 'F(') and (b.find (' U '+a+')') >= 0)): 
    rules[4][1]+=1;
    return b;
  #G(¬a) ∨ F(a) = true
  elif ((a[0:3] == 'G(¬') and (b[0:2] == 'F(') and (a[3:] == b[2:])): 
    rules[5][1]+=1;
    return True;
  #G(¬a) ∨ F(a ∧ ...) = F(a ∧ ...)
  elif ((a[0:3] == 'G(¬') and (b[0:2] == 'F(') and (b.find(a[3:-1]) >= 0)): 
    rules[6][1]+=1;
    return b;
  #a ∨ F(a) = F(a)
  elif ((b[0:2] == 'F(') and (b[2:-1] == a)): 
    rules[7][1]+=1;
    return b;
  # a ∨ (b ∧ a) = a
  elif (b.find(' ∧ '+a+')') >= 0): 
    rules[8][1]+=1;
    return a;
  #a ∨ (a ∨ b) = a V b | a ∨ (b ∨ a) = a ∨ b
  elif (b.find('('+a+' ∨ ') >= 0): 
    rules[9][1]+=1;
    return b;
  else: return '(' +a+ ' ∨ ' +b+ ')'

def con(a, b):
  if (a == False) or (b == False): return False;
  elif (a == True): return b;
  elif (b == True): return a;
  else: return '('+a+' ∧ '+b+')'

def no(a):
  if (type(a) == type(True)): return not a;
  else: return "¬" + a;

def impl(a, b):
  if ((type(a) == type(True)) or (type(b) == type(True))): return dis(no(a),b);
  else:  return '('+a+' → '+b+')'

def Future(a):
  if (type(a) == type(True)): return a;
  #F(F(a)) = F(a)
  elif ((a[0] == 'F')and (a[1] == '(') and (a[len(a)-1] == ')')): 
    rules[10][1]+=1;
    return a;
  #F(a  ∧ F(b)) = F(a ∧ b)
  elif (a.find(' ∧ F(') >= 0):
    t = a.find(' ∧ F(');
    b = a[t+4:-1];
    rules[11][1]+=1;
    if (b.find(' ') >=0):
      a = a.replace(' ∧ F', ' ∧ ');
      return 'F'+a;
    else:
      return 'F'+a[:t] + ' ∧ ' + b[1:-1]+ ')'
  elif (a[0] != '('): return 'F('+a+')';
  else: return 'F'+a+''

def Globally(a):
  if (type(a) == type(True)): return a;
  #G(F(a)) = GF(a)
  elif ((a[0] == 'F') and (a[1] == '(') and (a[len(a)-1] == ')')): 
    rules[12][1]+=1;
    return 'G'+a;
  #G(G(a)) = G(a)
  elif ((a[0] == 'G')and (a[1] == '(') and (a[len(a)-1] == ')')): 
    rules[13][1]+=1;
    return a;
  elif (a[0] != '('): return 'G('+a+')';
  #G(a → G(a)) = true
  #G((b ∧ a) → G(a)) = true
  #G(a → G(b)) = G(a → b)
  elif (a.find('→ G(') >= 0):
    t1 = a.find('→ G(');
    b = a[t1+3 : -1];
    a1 = a[1:t1-1];
    if ((b[0] == '(') and (b[-1] == ')')): b = b[1:-1];
    if ((a1[0] == '(') and (a1[-1] == ')')): a1 = a1[1:-1];
    if (a1 == b):
      rules[14][1]+=1;
      return True;
    if ((a1.find(' ∧ ' + b) >= 0)  or (a1.find(b + ' ∧ ') >= 0)):
      rules[15][1]+=1;
      return True;
    #G((b ∧ a) → G(a ∧ ¬c)) = G(¬(b ∧ a ∧ c))
    #G(a → G(a ∧ ¬c)) = G(¬(a ∧ c))
    if (b.find(' ∧ ¬') >= 0):
      t22 = b.find(' ∧ ¬');
      a22 = b[:t22];
      c22 = b[t22+4:];
      if (a1.find(' ∧ ') >= 0):
        t2 = a1.find(' ∧ ');
        b2 = a1[:t2];
        a2 = a1[t2+3:];
      else: 
        a2 = a1;
        b2 = '';
      if (a2 == a22):
        if (b2 != ''): 
          rules[17][1]+=1;
          return 'G(¬('+b2+' ∧ '+a2+' ∧ '+c22+'))';
        else: 
          rules[18][1]+=1;
          return 'G(¬('+a2+' ∧ '+c22+'))';
    else:
      a = a.replace('→ G', '→ ');
      rules[16][1]+=1;
      return 'G'+ a;
  else: return 'G'+a+''

def Until(a, b):
  if (b == False): return False;
  elif ((b == True) and (type(a) == type(True))): return True;
  elif ((a == False) and (type(b) != type(True))): return b;
  elif ((type(a) != type(True)) and (b == True)): return True;
  elif ((a == True) and (type(b) != type(True))): return Future(b);
  #φ U (φ U ψ) ≡ φ U ψ; 
  elif (b.find('('+a+' U ') >= 0): 
    rules[19][1]+=1;
    return b;
  else: return '('+a+' U '+b+')'

def WeakUntil(a, b):
  if ((type(a) == type(True)) and (type(b) == type(True))):
    if ((a == False) and (b == False)): return False;
    else: return True;
  elif ((type(b) != type(True)) and (type(a) != type(True))): return '('+a+' W '+b+')';
  elif (type(b) != type(True)):
    if (a == False): return b;
    elif (a == True): return True;
  elif (type(a) != type(True)):
    if (b == True): return True;
    elif (b == False): return Globally(a);

import pandas as pd
import numpy as np
from matplotlib import pyplot as plt 

data_frame = pd.read_csv('atributs.csv', encoding='utf8')

data_frame

def konv(a_txt):
  if (a_txt == 'true*'): return True;
  elif (a_txt == 'false*'): return False;
  else: return a_txt;

def BoolToString(a):
  if (type(a) == type(True)): 
    if (a == True): return "true";
    elif (a == False): return "false";
  else: return a;

a = 12
mas = [] 
for i1 in range(243): 
    mas.append([0] * a)


for i in data_frame.index:
  release_txt = data_frame['release'][i]
  delay_txt = data_frame['delay'][i]
  final_txt =  data_frame['final'][i]
  reaction_txt =  data_frame['reaction'][i]
  invariant_txt =  data_frame['invariant'][i]

  triggerVAR_txt = data_frame['trigerVAR'][i];
  triggerTrue_txt = data_frame['trigerTRUE'][i];

  release = konv(release_txt);
  delay = konv(delay_txt);
  final = konv(final_txt);
  reaction = konv(reaction_txt);
  invariant = konv(invariant_txt);

  trigger = 'trig'
  x0 = con(trigger, invariant);
  x1 = dis(release, reaction);
  x2 = con(invariant, delay);
  x3 = Until(x2, x1);
  x4 = con(final, x3);
  x5 = Until(invariant, x4);
  x6 = con (invariant, no(final));
  x7 = WeakUntil(x6, release);
  x8 = dis(x7, x5);
  x9 = impl(x0, x8);
  x10 = Globally(x9);

  
  trigger = True
  
  y0 = con(trigger, invariant);
  y1 = dis(release, reaction);
  y2 = con(invariant, delay);
  y3 = Until(y2, y1);
  y4 = con(final, y3);
  y5 = Until(invariant, y4);
  y6 = con (invariant, no(final));
  y7 = WeakUntil(y6, release);
  y8 = dis(y7, y5);
  y9 = impl(y0, y8);
  y10 = Globally(y9);

  trigger = False
  z1 = True;
  
  mas[i][0]=BoolToString(release);
  mas[i][1]=BoolToString(delay);
  mas[i][2]=BoolToString(final);
  mas[i][3]=BoolToString(reaction);
  mas[i][4]=BoolToString(invariant);

  mas[i][5]=BoolToString(x10);
  mas[i][6]=BoolToString(y10);
  mas[i][7]=BoolToString(z1);

for i in range(0, len(mas)):
    for i2 in range(0, len(mas[i])):
        print(mas[i][i2], end=' ')
    print()


from openpyxl import Workbook
wb = Workbook()
ws = wb.active


for subarray in mas:
    ws.append(subarray)
wb.save('./edtl-ltl.xlsx')